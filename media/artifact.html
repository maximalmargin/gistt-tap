<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>gistt - artifact</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            position: fixed;
            top: 0;
            left: 0;
            background: #0a0e27;
        }
        
        body {
            font-family: 'Courier New', monospace;
            -webkit-overflow-scrolling: touch;
        }
        
        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        /* Subtle scanlines for retro terminal effect */
        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.05),
                rgba(0, 0, 0, 0.05) 1px,
                transparent 1px,
                transparent 2px
            );
            z-index: 100;
            opacity: 0.3;
        }
        
        .title {
            position: absolute;
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 64px;
            font-weight: 300;
            color: #00d9ff;
            text-shadow: 0 0 20px rgba(0, 217, 255, 0.5);
            letter-spacing: 0.2em;
            z-index: 10;
            padding: 0 20px;
            text-align: center;
            white-space: nowrap;
        }
        
        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .title {
                font-size: 48px;
                letter-spacing: 0.15em;
                bottom: 12%;
            }
        }
        
        @media (max-width: 480px) {
            .title {
                font-size: 36px;
                letter-spacing: 0.1em;
                bottom: 10%;
            }
        }
        
        @media (max-width: 360px) {
            .title {
                font-size: 28px;
                letter-spacing: 0.08em;
            }
        }
    </style>
</head>
<body>
    <div class="scanlines"></div>
    <canvas id="canvas"></canvas>
    <div class="title">gistt</div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Function to set proper canvas size for all devices
        function setCanvasSize() {
            // Use clientWidth/clientHeight for accurate dimensions
            const width = window.innerWidth || document.documentElement.clientWidth;
            const height = window.innerHeight || document.documentElement.clientHeight;
            
            // Set canvas internal resolution to match display size
            canvas.width = width;
            canvas.height = height;
            
            return { width, height };
        }
        
        // Set initial canvas size
        const { width: initialWidth, height: initialHeight } = setCanvasSize();
        
        // Responsive settings based on viewport
        const isMobile = initialWidth <= 768;
        const isSmallMobile = initialWidth <= 480;
        
        // Color palette (matching app design)
        // Background: #0a0e27 (10, 14, 39)
        // Primary cyan: #00d9ff (0, 217, 255) - borders, titles, lens
        // Neon green: #39ff14 (57, 255, 20) - active states
        // Neon pink: #ff6ec7 (255, 110, 199) - highlights
        // Warm yellow: #f9f871 (249, 248, 113) - warnings, text
        // Electric cyan: #7df9ff (125, 249, 255) - labels, borders
        
        // Email fragments for left side - longer and more overwhelming
        const emailFragments = [
            'Re: Meeting tomorrow at 3pm - please confirm your availability',
            'FW: Q3 Quarterly Report needs your review by EOD Friday',
            'Action Required: Review and approve the marketing budget proposal',
            'Update on Project X: Timeline has shifted, need urgent discussion',
            'Quick question about the client deliverables and next steps',
            'Follow-up from today\'s standup - action items assigned to you',
            'URGENT: Please respond to legal team inquiry before 5pm',
            'Invitation: All-hands Team Sync - Wednesday 2pm (Required)',
            'Reminder: Performance review deadline is this Thursday',
            'Feedback requested: New feature design mockups attached',
            'Thanks for your help on the presentation - few clarifications',
            'Can we schedule a call to discuss the roadmap priorities?',
            'Updates and next steps on the vendor contract negotiation',
            'Please review attached documents and provide your signature',
            'Checking in on status of the deliverables we discussed',
            'FYI: IT maintenance window scheduled for this weekend',
            'Re: Your expense report submission - missing receipts',
            'Stakeholder meeting notes from yesterday + action items',
            'Draft proposal for your review - deadline Monday morning',
            'Question about the implementation approach and timeline',
            'Following up on our conversation from last week\'s meeting',
            'Update: Budget allocation for Q4 initiatives and planning',
            'Coordination needed: Multiple teams waiting on your input',
            'Approval needed for vendor invoice #2847 before processing',
            'Re: Re: Re: Project timeline - final decision required now'
        ];
        
        const envelopePalettes = [
            { body: 'rgba(70, 88, 140, 0.55)', flap: 'rgba(125, 249, 255, 0.35)', border: 'rgba(125, 249, 255, 0.45)' },
            { body: 'rgba(32, 42, 74, 0.6)', flap: 'rgba(249, 248, 113, 0.3)', border: 'rgba(249, 248, 113, 0.35)' },
            { body: 'rgba(84, 62, 102, 0.5)', flap: 'rgba(255, 110, 199, 0.3)', border: 'rgba(255, 110, 199, 0.35)' },
            { body: 'rgba(49, 69, 94, 0.55)', flap: 'rgba(61, 255, 20, 0.25)', border: 'rgba(61, 255, 20, 0.3)' },
        ];
        
        // Generate messy email blocks
        class EmailBlock {
            constructor() {
                this.resetPosition();
            }
            
            resetPosition() {
                this.layer = Math.random();
                // Scale down email blocks on mobile
                const mobileScale = isSmallMobile ? 0.6 : (isMobile ? 0.75 : 1.0);
                this.scale = (0.65 + Math.random() * 0.6) * mobileScale;
                this.width = (120 + Math.random() * 180) * this.scale;
                this.height = (60 + Math.random() * 40) * this.scale;
                this.x = -this.width - Math.random() * canvas.width * 0.25;
                this.y = Math.random() * canvas.height;
                this.float = Math.random() * Math.PI * 2;
                this.floatSpeed = 0.003 + Math.random() * 0.004;
                this.rotation = (Math.random() - 0.5) * 0.45;
                this.rotationSpeed = (Math.random() - 0.5) * 0.001;
                this.velocityX = 0.3 + this.layer * 0.6;
                this.velocityY = (Math.random() - 0.5) * 0.2;
                this.text = emailFragments[Math.floor(Math.random() * emailFragments.length)];
                this.opacity = 0.35 + Math.random() * 0.4;
                this.palette = envelopePalettes[Math.floor(Math.random() * envelopePalettes.length)];
            }
            
            update() {
                this.x += this.velocityX;
                this.y += this.velocityY + Math.sin(this.float) * 0.2;
                this.float += this.floatSpeed;
                this.rotation += this.rotationSpeed;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                ctx.rotate(this.rotation);
                
                // Envelope body
                ctx.fillStyle = this.palette.body;
                ctx.strokeStyle = this.palette.border;
                ctx.lineWidth = 1.2;
                ctx.beginPath();
                ctx.rect(-this.width / 2, -this.height / 2, this.width, this.height);
                ctx.fill();
                ctx.stroke();
                
                // Envelope flap
                ctx.beginPath();
                ctx.moveTo(-this.width / 2, -this.height / 2);
                ctx.lineTo(0, 0);
                ctx.lineTo(this.width / 2, -this.height / 2);
                ctx.closePath();
                ctx.fillStyle = this.palette.flap;
                ctx.fill();
                ctx.stroke();
                
                // Inner fold lines
                ctx.strokeStyle = `rgba(255, 255, 255, ${this.opacity * 0.4})`;
                ctx.lineWidth = 0.8;
                ctx.beginPath();
                ctx.moveTo(-this.width / 2, this.height / 2);
                ctx.lineTo(0, 0);
                ctx.lineTo(this.width / 2, this.height / 2);
                ctx.stroke();
                
                // Highlight text fragments, clipped inside envelope
                const textPadding = 10;
                const maxTextWidth = Math.max(20, this.width - textPadding * 2);
                let fontSize = 7 + this.scale * 2.5;
                fontSize = Math.max(7, Math.min(fontSize, maxTextWidth / 5.5));
                ctx.fillStyle = `rgba(249, 248, 113, ${this.opacity})`;
                ctx.font = `${fontSize}px Courier New`;
                ctx.textBaseline = 'top';
                const charWidth = ctx.measureText('M').width || (fontSize * 0.6);
                const maxChars = Math.max(4, Math.floor(maxTextWidth / charWidth));
                const rawText = this.text;
                const lines = [];
                let index = 0;
                while (index < rawText.length && lines.length < 2) {
                    let slice = rawText.substring(index, index + maxChars);
                    if (slice.length === maxChars && index + maxChars < rawText.length) {
                        const lastSpace = slice.lastIndexOf(' ');
                        if (lastSpace > 4) {
                            slice = slice.substring(0, lastSpace);
                            index += lastSpace + 1;
                        } else {
                            index += maxChars;
                        }
                    } else {
                        index += slice.length;
                    }
                    lines.push(slice.trim());
                }
                if (index < rawText.length && lines.length > 0) {
                    lines[lines.length - 1] = `${lines[lines.length - 1]}â€¦`;
                }
                
                ctx.save();
                ctx.beginPath();
                ctx.rect(
                    -this.width / 2 + textPadding,
                    -this.height / 2 + textPadding,
                    maxTextWidth,
                    this.height - textPadding * 2,
                );
                ctx.clip();
                lines.forEach((line, lineIndex) => {
                    ctx.fillText(
                        line,
                        -this.width / 2 + textPadding,
                        -this.height / 2 + textPadding + lineIndex * (fontSize + 2),
                    );
                });
                ctx.restore();
                
                // Glow
                ctx.shadowBlur = 25 * this.layer;
                ctx.shadowColor = this.palette.border;
                ctx.strokeStyle = `rgba(125, 249, 255, ${this.opacity * 0.25})`;
                ctx.strokeRect(-this.width / 2, -this.height / 2, this.width, this.height);
                ctx.shadowBlur = 0;
                
                ctx.restore();
            }
        }
        
        // Center transformation element
        class TransformationLens {
            constructor() {
                this.x = canvas.width / 2;
                this.y = canvas.height / 2;
                // Responsive radius based on screen size
                this.radius = isSmallMobile ? 40 : (isMobile ? 50 : 60);
                this.pulse = 0;
                // More responsive on mobile for better touch following
                this.ease = isMobile ? 0.15 : 0.08;
                this.currentRadius = this.radius;
            }
            
            update(pointerTarget) {
                this.pulse += 0.02;
                const targetX = pointerTarget.active ? pointerTarget.x : canvas.width / 2;
                const targetY = pointerTarget.active ? pointerTarget.y : canvas.height / 2;
                
                // Use higher ease factor on mobile when touch is active
                const currentEase = (isMobile && pointerTarget.active) ? 0.2 : this.ease;
                this.x += (targetX - this.x) * currentEase;
                this.y += (targetY - this.y) * currentEase;
                this.currentRadius = this.radius + Math.sin(this.pulse) * 5;
            }
            
            draw() {
                const pulseRadius = this.currentRadius;
                
                // Outer glow with retro CRT effect
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, pulseRadius * 2.5
                );
                gradient.addColorStop(0, 'rgba(0, 217, 255, 0.4)');
                gradient.addColorStop(0.3, 'rgba(0, 217, 255, 0.2)');
                gradient.addColorStop(0.6, 'rgba(0, 217, 255, 0.1)');
                gradient.addColorStop(1, 'rgba(0, 217, 255, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, pulseRadius * 2.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Main circle
                ctx.strokeStyle = '#00d9ff';
                ctx.lineWidth = 2;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#00d9ff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, pulseRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                // Inner geometric pattern
                ctx.strokeStyle = 'rgba(0, 217, 255, 0.3)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i + this.pulse;
                    const x1 = this.x + Math.cos(angle) * pulseRadius * 0.7;
                    const y1 = this.y + Math.sin(angle) * pulseRadius * 0.7;
                    const x2 = this.x + Math.cos(angle + Math.PI) * pulseRadius * 0.7;
                    const y2 = this.y + Math.sin(angle + Math.PI) * pulseRadius * 0.7;
                    
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }
            }
        }
        
        // Clear geometric shapes on right
        class ClearShape {
            constructor(type, color, index, totalCount) {
                this.type = type; // 'square', 'triangle', 'arrow'
                this.color = color;
                this.index = index;
                // Responsive size based on screen size
                this.size = isSmallMobile ? 24 : (isMobile ? 28 : 32);
            }
            
            update() {
                // Static shapes; no per-frame adjustments required.
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                ctx.fillStyle = this.color;
                
                const boxSize = this.size;
                const halfBox = boxSize / 2;
                
                const drawEquilateral = (rotationRadians) => {
                    const triangleSide = boxSize; // match the square edge length
                    const triangleHeight = Math.sqrt(3) / 2 * triangleSide;
                    const halfHeight = triangleHeight / 2;
                    
                    ctx.save();
                    ctx.rotate(rotationRadians);
                    ctx.beginPath();
                    ctx.moveTo(0, -halfHeight);
                    ctx.lineTo(triangleSide / 2, halfHeight);
                    ctx.lineTo(-triangleSide / 2, halfHeight);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                };
                
                if (this.type === 'square') {
                    const squareSize = boxSize * 0.92;
                    const halfSquare = squareSize / 2;
                    ctx.beginPath();
                    ctx.rect(-halfSquare, -halfSquare, squareSize, squareSize);
                    ctx.fill();
                } else if (this.type === 'triangle') {
                    drawEquilateral(0);
                } else if (this.type === 'arrow') {
                    drawEquilateral(Math.PI / 2);
                }
                
                ctx.shadowBlur = 0;
                ctx.restore();
            }
            
            getMetrics() {
                const triangleSide = this.size;
                const triangleHeight = Math.sqrt(3) / 2 * triangleSide;
                
                if (this.type === 'square') {
                    const squareSize = this.size * 0.92;
                    return { halfWidth: squareSize / 2, height: squareSize };
                }
                
                if (this.type === 'triangle') {
                    return { halfWidth: triangleSide / 2, height: triangleHeight };
                }
                
                // Arrow is a rotated equilateral triangle
                return { halfWidth: triangleHeight / 2, height: triangleSide };
            }
        }
        
        const positionShapes = (shapeList) => {
            // Responsive padding and gap based on screen size
            const rightPadding = isSmallMobile ? 30 : (isMobile ? 50 : 80);
            const gap = isSmallMobile ? 24 : (isMobile ? 30 : 36);
            const heights = shapeList.map(shape => shape.getMetrics().height);
            const totalHeight = heights.reduce((sum, h) => sum + h, 0) + gap * (shapeList.length - 1);
            let currentY = canvas.height / 2 - totalHeight / 2;
            
            shapeList.forEach((shape, index) => {
                const { halfWidth, height } = shape.getMetrics();
                shape.x = canvas.width - rightPadding - halfWidth;
                shape.y = currentY + height / 2;
                if (shape.type === 'arrow') {
                    shape.y += 6;
                }
                currentY += height + gap;
            });
        };
        
        // Particle system for transformation
        class Particle {
            constructor() {
                this.reset();
            }
            
            reset() {
                // Spawn from left side with more spread
                this.x = canvas.width * 0.25 + Math.random() * 150;
                this.y = Math.random() * canvas.height;
                this.size = 0.8 + Math.random() * 1.5;
                this.speed = 0.015 + Math.random() * 0.025;
                this.baseOpacity = 0.25 + Math.random() * 0.4;
                this.opacity = this.baseOpacity;
                this.life = 1.0;
                this.maxLife = 100 + Math.random() * 100; // frames before reset
                this.age = 0;
            }
            
            update(targetX, targetY) {
                // Update position toward current target
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                this.x += dx * this.speed;
                this.y += dy * this.speed;
                
                // Age the particle
                this.age++;
                
                // Fade out as it approaches target or ages
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < 30) {
                    this.life -= 0.05;
                } else if (this.age > this.maxLife * 0.7) {
                    this.life -= 0.02;
                }
                
                this.opacity = this.baseOpacity * this.life;
                
                // Reset if too close, too old, or faded out
                if (distance < 5 || this.age > this.maxLife || this.life <= 0) {
                    this.reset();
                }
            }
            
            draw() {
                if (this.opacity > 0) {
                    ctx.fillStyle = `rgba(0, 217, 255, ${this.opacity})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        // Initialize elements - more blocks for overwhelming effect
        // Reduce count on mobile for better performance
        const emailBlockCount = isSmallMobile ? 30 : (isMobile ? 45 : 70);
        const particleCount = isSmallMobile ? 15 : (isMobile ? 25 : 35);
        const emailBlocks = Array.from({ length: emailBlockCount }, () => new EmailBlock());
        const lens = new TransformationLens();
        const particles = Array.from({ length: particleCount }, () => new Particle());
        const shapeConfigs = [
            { type: 'square', color: '#ff6ec7' },
            { type: 'triangle', color: '#f9f871' },
            { type: 'arrow', color: '#39ff14' },
        ];
        const shapes = shapeConfigs.map((config, index) => new ClearShape(config.type, config.color, index, shapeConfigs.length));
        positionShapes(shapes);
        const pointer = { x: canvas.width / 2, y: canvas.height / 2, active: false };
        
        window.addEventListener('mousemove', (event) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            pointer.x = (event.clientX - rect.left) * scaleX;
            pointer.y = (event.clientY - rect.top) * scaleY;
            pointer.active = true;
        });
        
        window.addEventListener('mouseleave', () => {
            pointer.active = false;
        });
        
        window.addEventListener('blur', () => {
            pointer.active = false;
        });
        
        // Touch support for mobile devices
        function handleTouch(event) {
            event.preventDefault();
            if (event.touches.length > 0) {
                const touch = event.touches[0];
                
                // Get accurate canvas position accounting for all offsets
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                // Calculate touch position relative to canvas with proper scaling
                pointer.x = (touch.clientX - rect.left) * scaleX;
                pointer.y = (touch.clientY - rect.top) * scaleY;
                pointer.active = true;
            }
        }
        
        canvas.addEventListener('touchstart', handleTouch, { passive: false });
        canvas.addEventListener('touchmove', handleTouch, { passive: false });
        
        canvas.addEventListener('touchend', (event) => {
            event.preventDefault();
            pointer.active = false;
        }, { passive: false });
        
        canvas.addEventListener('touchcancel', (event) => {
            event.preventDefault();
            pointer.active = false;
        }, { passive: false });
        
        // Prevent default touch behavior on the document to avoid scrolling
        document.body.addEventListener('touchstart', (e) => {
            if (e.target === canvas) {
                e.preventDefault();
            }
        }, { passive: false });
        
        document.body.addEventListener('touchmove', (e) => {
            if (e.target === canvas) {
                e.preventDefault();
            }
        }, { passive: false });
        
        // Animation loop
        function animate() {
            // Clear with slight trail effect
            ctx.fillStyle = 'rgba(10, 14, 39, 0.95)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Update transformation lens based on pointer
            lens.update(pointer);
            
            // Draw email blocks and reset when they reach the transformation lens
            emailBlocks.forEach(block => {
                block.update();
                const centerX = block.x + block.width / 2;
                const centerY = block.y + block.height / 2;
                const dx = centerX - lens.x;
                const dy = centerY - lens.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const blockRadius = Math.max(block.width, block.height) / 2;
                if (distance <= lens.currentRadius + blockRadius) {
                    block.resetPosition();
                } else {
                    block.draw();
                }
            });
            
            // Draw particles
            particles.forEach(particle => {
                particle.update(lens.x, lens.y);
                particle.draw();
            });
            
            // Draw transformation lens
            lens.draw();
            
            // Draw clear shapes
            shapes.forEach(shape => {
                shape.update();
                shape.draw();
            });
            
            // DEBUG: Draw touch/pointer indicator when active
            if (pointer.active) {
                ctx.save();
                // Draw a small crosshair at the exact pointer position
                ctx.strokeStyle = '#ff00ff';
                ctx.lineWidth = 2;
                const crossSize = 20;
                
                // Horizontal line
                ctx.beginPath();
                ctx.moveTo(pointer.x - crossSize, pointer.y);
                ctx.lineTo(pointer.x + crossSize, pointer.y);
                ctx.stroke();
                
                // Vertical line
                ctx.beginPath();
                ctx.moveTo(pointer.x, pointer.y - crossSize);
                ctx.lineTo(pointer.x, pointer.y + crossSize);
                ctx.stroke();
                
                // Small circle
                ctx.beginPath();
                ctx.arc(pointer.x, pointer.y, 5, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }
            
            requestAnimationFrame(animate);
        }
        
        // Handle resize and orientation changes
        function handleResize() {
            // Update canvas size
            const { width, height } = setCanvasSize();
            
            // Update responsive settings
            const newIsMobile = width <= 768;
            const newIsSmallMobile = width <= 480;
            
            // Update lens position, radius, and responsiveness
            lens.x = canvas.width / 2;
            lens.y = canvas.height / 2;
            lens.radius = newIsSmallMobile ? 40 : (newIsMobile ? 50 : 60);
            lens.currentRadius = lens.radius;
            lens.ease = newIsMobile ? 0.15 : 0.08;
            pointer.x = canvas.width / 2;
            pointer.y = canvas.height / 2;
            pointer.active = false;
            
            // Update shape sizes
            shapes.forEach(shape => {
                shape.size = newIsSmallMobile ? 24 : (newIsMobile ? 28 : 32);
            });
            
            // Update clear shapes positions
            positionShapes(shapes);
            
            // Update particle targets
            particles.forEach(particle => {
                particle.targetX = canvas.width * 0.5;
                particle.targetY = canvas.height * 0.5;
            });
        }
        
        window.addEventListener('resize', handleResize);
        window.addEventListener('orientationchange', () => {
            // Small delay to ensure viewport has updated
            setTimeout(handleResize, 100);
        });
        
        // Start animation
        animate();
    </script>
</body>
</html>
