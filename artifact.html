<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gistt - artifact</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #0a0e27;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
        
        canvas {
            display: block;
        }
        
        /* Subtle scanlines for retro terminal effect */
        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.05),
                rgba(0, 0, 0, 0.05) 1px,
                transparent 1px,
                transparent 2px
            );
            z-index: 100;
            opacity: 0.3;
        }
        
        .title {
            position: absolute;
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 64px;
            font-weight: 300;
            color: #00d9ff;
            text-shadow: 0 0 20px rgba(0, 217, 255, 0.5);
            letter-spacing: 0.2em;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div class="scanlines"></div>
    <canvas id="canvas"></canvas>
    <div class="title">gistt</div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Color palette (matching app design)
        // Background: #0a0e27 (10, 14, 39)
        // Primary cyan: #00d9ff (0, 217, 255) - borders, titles, lens
        // Neon green: #39ff14 (57, 255, 20) - active states
        // Neon pink: #ff6ec7 (255, 110, 199) - highlights
        // Warm yellow: #f9f871 (249, 248, 113) - warnings, text
        // Electric cyan: #7df9ff (125, 249, 255) - labels, borders
        
        // Email fragments for left side - longer and more overwhelming
        const emailFragments = [
            'Re: Meeting tomorrow at 3pm - please confirm your availability',
            'FW: Q3 Quarterly Report needs your review by EOD Friday',
            'Action Required: Review and approve the marketing budget proposal',
            'Update on Project X: Timeline has shifted, need urgent discussion',
            'Quick question about the client deliverables and next steps',
            'Follow-up from today\'s standup - action items assigned to you',
            'URGENT: Please respond to legal team inquiry before 5pm',
            'Invitation: All-hands Team Sync - Wednesday 2pm (Required)',
            'Reminder: Performance review deadline is this Thursday',
            'Feedback requested: New feature design mockups attached',
            'Thanks for your help on the presentation - few clarifications',
            'Can we schedule a call to discuss the roadmap priorities?',
            'Updates and next steps on the vendor contract negotiation',
            'Please review attached documents and provide your signature',
            'Checking in on status of the deliverables we discussed',
            'FYI: IT maintenance window scheduled for this weekend',
            'Re: Your expense report submission - missing receipts',
            'Stakeholder meeting notes from yesterday + action items',
            'Draft proposal for your review - deadline Monday morning',
            'Question about the implementation approach and timeline',
            'Following up on our conversation from last week\'s meeting',
            'Update: Budget allocation for Q4 initiatives and planning',
            'Coordination needed: Multiple teams waiting on your input',
            'Approval needed for vendor invoice #2847 before processing',
            'Re: Re: Re: Project timeline - final decision required now'
        ];
        
        const envelopePalettes = [
            { body: 'rgba(70, 88, 140, 0.55)', flap: 'rgba(125, 249, 255, 0.35)', border: 'rgba(125, 249, 255, 0.45)' },
            { body: 'rgba(32, 42, 74, 0.6)', flap: 'rgba(249, 248, 113, 0.3)', border: 'rgba(249, 248, 113, 0.35)' },
            { body: 'rgba(84, 62, 102, 0.5)', flap: 'rgba(255, 110, 199, 0.3)', border: 'rgba(255, 110, 199, 0.35)' },
            { body: 'rgba(49, 69, 94, 0.55)', flap: 'rgba(61, 255, 20, 0.25)', border: 'rgba(61, 255, 20, 0.3)' },
        ];
        
        // Generate messy email blocks
        class EmailBlock {
            constructor() {
                this.resetPosition();
            }
            
            resetPosition() {
                this.layer = Math.random();
                this.scale = 0.65 + Math.random() * 0.6;
                this.width = (120 + Math.random() * 180) * this.scale;
                this.height = (60 + Math.random() * 40) * this.scale;
                this.x = -this.width - Math.random() * canvas.width * 0.25;
                this.y = Math.random() * canvas.height;
                this.float = Math.random() * Math.PI * 2;
                this.floatSpeed = 0.003 + Math.random() * 0.004;
                this.rotation = (Math.random() - 0.5) * 0.45;
                this.rotationSpeed = (Math.random() - 0.5) * 0.001;
                this.velocityX = 0.3 + this.layer * 0.6;
                this.velocityY = (Math.random() - 0.5) * 0.2;
                this.text = emailFragments[Math.floor(Math.random() * emailFragments.length)];
                this.opacity = 0.35 + Math.random() * 0.4;
                this.palette = envelopePalettes[Math.floor(Math.random() * envelopePalettes.length)];
            }
            
            update() {
                this.x += this.velocityX;
                this.y += this.velocityY + Math.sin(this.float) * 0.2;
                this.float += this.floatSpeed;
                this.rotation += this.rotationSpeed;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                ctx.rotate(this.rotation);
                
                // Envelope body
                ctx.fillStyle = this.palette.body;
                ctx.strokeStyle = this.palette.border;
                ctx.lineWidth = 1.2;
                ctx.beginPath();
                ctx.rect(-this.width / 2, -this.height / 2, this.width, this.height);
                ctx.fill();
                ctx.stroke();
                
                // Envelope flap
                ctx.beginPath();
                ctx.moveTo(-this.width / 2, -this.height / 2);
                ctx.lineTo(0, 0);
                ctx.lineTo(this.width / 2, -this.height / 2);
                ctx.closePath();
                ctx.fillStyle = this.palette.flap;
                ctx.fill();
                ctx.stroke();
                
                // Inner fold lines
                ctx.strokeStyle = `rgba(255, 255, 255, ${this.opacity * 0.4})`;
                ctx.lineWidth = 0.8;
                ctx.beginPath();
                ctx.moveTo(-this.width / 2, this.height / 2);
                ctx.lineTo(0, 0);
                ctx.lineTo(this.width / 2, this.height / 2);
                ctx.stroke();
                
                // Highlight text fragments, clipped inside envelope
                const textPadding = 10;
                const maxTextWidth = Math.max(20, this.width - textPadding * 2);
                let fontSize = 7 + this.scale * 2.5;
                fontSize = Math.max(7, Math.min(fontSize, maxTextWidth / 5.5));
                ctx.fillStyle = `rgba(249, 248, 113, ${this.opacity})`;
                ctx.font = `${fontSize}px Courier New`;
                ctx.textBaseline = 'top';
                const charWidth = ctx.measureText('M').width || (fontSize * 0.6);
                const maxChars = Math.max(4, Math.floor(maxTextWidth / charWidth));
                const rawText = this.text;
                const lines = [];
                let index = 0;
                while (index < rawText.length && lines.length < 2) {
                    let slice = rawText.substring(index, index + maxChars);
                    if (slice.length === maxChars && index + maxChars < rawText.length) {
                        const lastSpace = slice.lastIndexOf(' ');
                        if (lastSpace > 4) {
                            slice = slice.substring(0, lastSpace);
                            index += lastSpace + 1;
                        } else {
                            index += maxChars;
                        }
                    } else {
                        index += slice.length;
                    }
                    lines.push(slice.trim());
                }
                if (index < rawText.length && lines.length > 0) {
                    lines[lines.length - 1] = `${lines[lines.length - 1]}â€¦`;
                }
                
                ctx.save();
                ctx.beginPath();
                ctx.rect(
                    -this.width / 2 + textPadding,
                    -this.height / 2 + textPadding,
                    maxTextWidth,
                    this.height - textPadding * 2,
                );
                ctx.clip();
                lines.forEach((line, lineIndex) => {
                    ctx.fillText(
                        line,
                        -this.width / 2 + textPadding,
                        -this.height / 2 + textPadding + lineIndex * (fontSize + 2),
                    );
                });
                ctx.restore();
                
                // Glow
                ctx.shadowBlur = 25 * this.layer;
                ctx.shadowColor = this.palette.border;
                ctx.strokeStyle = `rgba(125, 249, 255, ${this.opacity * 0.25})`;
                ctx.strokeRect(-this.width / 2, -this.height / 2, this.width, this.height);
                ctx.shadowBlur = 0;
                
                ctx.restore();
            }
        }
        
        // Center transformation element
        class TransformationLens {
            constructor() {
                this.x = canvas.width / 2;
                this.y = canvas.height / 2;
                this.radius = 60;
                this.pulse = 0;
                this.ease = 0.08;
                this.currentRadius = this.radius;
            }
            
            update(pointerTarget) {
                this.pulse += 0.02;
                const targetX = pointerTarget.active ? pointerTarget.x : canvas.width / 2;
                const targetY = pointerTarget.active ? pointerTarget.y : canvas.height / 2;
                this.x += (targetX - this.x) * this.ease;
                this.y += (targetY - this.y) * this.ease;
                this.currentRadius = this.radius + Math.sin(this.pulse) * 5;
            }
            
            draw() {
                const pulseRadius = this.currentRadius;
                
                // Outer glow with retro CRT effect
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, pulseRadius * 2.5
                );
                gradient.addColorStop(0, 'rgba(0, 217, 255, 0.4)');
                gradient.addColorStop(0.3, 'rgba(0, 217, 255, 0.2)');
                gradient.addColorStop(0.6, 'rgba(0, 217, 255, 0.1)');
                gradient.addColorStop(1, 'rgba(0, 217, 255, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, pulseRadius * 2.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Main circle
                ctx.strokeStyle = '#00d9ff';
                ctx.lineWidth = 2;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#00d9ff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, pulseRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                // Inner geometric pattern
                ctx.strokeStyle = 'rgba(0, 217, 255, 0.3)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i + this.pulse;
                    const x1 = this.x + Math.cos(angle) * pulseRadius * 0.7;
                    const y1 = this.y + Math.sin(angle) * pulseRadius * 0.7;
                    const x2 = this.x + Math.cos(angle + Math.PI) * pulseRadius * 0.7;
                    const y2 = this.y + Math.sin(angle + Math.PI) * pulseRadius * 0.7;
                    
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }
            }
        }
        
        // Clear geometric shapes on right
        class ClearShape {
            constructor(type, color, index, totalCount) {
                this.type = type; // 'square', 'triangle', 'arrow'
                this.color = color;
                this.index = index;
                this.size = 32;
            }
            
            update() {
                // Static shapes; no per-frame adjustments required.
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                ctx.fillStyle = this.color;
                
                const boxSize = this.size;
                const halfBox = boxSize / 2;
                
                const drawEquilateral = (rotationRadians) => {
                    const triangleSide = boxSize; // match the square edge length
                    const triangleHeight = Math.sqrt(3) / 2 * triangleSide;
                    const halfHeight = triangleHeight / 2;
                    
                    ctx.save();
                    ctx.rotate(rotationRadians);
                    ctx.beginPath();
                    ctx.moveTo(0, -halfHeight);
                    ctx.lineTo(triangleSide / 2, halfHeight);
                    ctx.lineTo(-triangleSide / 2, halfHeight);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                };
                
                if (this.type === 'square') {
                    const squareSize = boxSize * 0.92;
                    const halfSquare = squareSize / 2;
                    ctx.beginPath();
                    ctx.rect(-halfSquare, -halfSquare, squareSize, squareSize);
                    ctx.fill();
                } else if (this.type === 'triangle') {
                    drawEquilateral(0);
                } else if (this.type === 'arrow') {
                    drawEquilateral(Math.PI / 2);
                }
                
                ctx.shadowBlur = 0;
                ctx.restore();
            }
            
            getMetrics() {
                const triangleSide = this.size;
                const triangleHeight = Math.sqrt(3) / 2 * triangleSide;
                
                if (this.type === 'square') {
                    const squareSize = this.size * 0.92;
                    return { halfWidth: squareSize / 2, height: squareSize };
                }
                
                if (this.type === 'triangle') {
                    return { halfWidth: triangleSide / 2, height: triangleHeight };
                }
                
                // Arrow is a rotated equilateral triangle
                return { halfWidth: triangleHeight / 2, height: triangleSide };
            }
        }
        
        const positionShapes = (shapeList) => {
            const rightPadding = 80;
            const gap = 36;
            const heights = shapeList.map(shape => shape.getMetrics().height);
            const totalHeight = heights.reduce((sum, h) => sum + h, 0) + gap * (shapeList.length - 1);
            let currentY = canvas.height / 2 - totalHeight / 2;
            
            shapeList.forEach((shape, index) => {
                const { halfWidth, height } = shape.getMetrics();
                shape.x = canvas.width - rightPadding - halfWidth;
                shape.y = currentY + height / 2;
                if (shape.type === 'arrow') {
                    shape.y += 6;
                }
                currentY += height + gap;
            });
        };
        
        // Particle system for transformation
        class Particle {
            constructor() {
                this.reset();
            }
            
            reset() {
                // Spawn from left side with more spread
                this.x = canvas.width * 0.25 + Math.random() * 150;
                this.y = Math.random() * canvas.height;
                this.size = 0.8 + Math.random() * 1.5;
                this.speed = 0.015 + Math.random() * 0.025;
                this.baseOpacity = 0.25 + Math.random() * 0.4;
                this.opacity = this.baseOpacity;
                this.life = 1.0;
                this.maxLife = 100 + Math.random() * 100; // frames before reset
                this.age = 0;
            }
            
            update(targetX, targetY) {
                // Update position toward current target
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                this.x += dx * this.speed;
                this.y += dy * this.speed;
                
                // Age the particle
                this.age++;
                
                // Fade out as it approaches target or ages
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < 30) {
                    this.life -= 0.05;
                } else if (this.age > this.maxLife * 0.7) {
                    this.life -= 0.02;
                }
                
                this.opacity = this.baseOpacity * this.life;
                
                // Reset if too close, too old, or faded out
                if (distance < 5 || this.age > this.maxLife || this.life <= 0) {
                    this.reset();
                }
            }
            
            draw() {
                if (this.opacity > 0) {
                    ctx.fillStyle = `rgba(0, 217, 255, ${this.opacity})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        // Initialize elements - more blocks for overwhelming effect
        const emailBlocks = Array.from({ length: 70 }, () => new EmailBlock());
        const lens = new TransformationLens();
        const particles = Array.from({ length: 35 }, () => new Particle());
        const shapeConfigs = [
            { type: 'square', color: '#ff6ec7' },
            { type: 'triangle', color: '#f9f871' },
            { type: 'arrow', color: '#39ff14' },
        ];
        const shapes = shapeConfigs.map((config, index) => new ClearShape(config.type, config.color, index, shapeConfigs.length));
        positionShapes(shapes);
        const pointer = { x: canvas.width / 2, y: canvas.height / 2, active: false };
        
        window.addEventListener('mousemove', (event) => {
            const rect = canvas.getBoundingClientRect();
            pointer.x = event.clientX - rect.left;
            pointer.y = event.clientY - rect.top;
            pointer.active = true;
        });
        
        window.addEventListener('mouseleave', () => {
            pointer.active = false;
        });
        
        window.addEventListener('blur', () => {
            pointer.active = false;
        });
        
        // Animation loop
        function animate() {
            // Clear with slight trail effect
            ctx.fillStyle = 'rgba(10, 14, 39, 0.95)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Update transformation lens based on pointer
            lens.update(pointer);
            
            // Draw email blocks and reset when they reach the transformation lens
            emailBlocks.forEach(block => {
                block.update();
                const centerX = block.x + block.width / 2;
                const centerY = block.y + block.height / 2;
                const dx = centerX - lens.x;
                const dy = centerY - lens.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const blockRadius = Math.max(block.width, block.height) / 2;
                if (distance <= lens.currentRadius + blockRadius) {
                    block.resetPosition();
                } else {
                    block.draw();
                }
            });
            
            // Draw particles
            particles.forEach(particle => {
                particle.update(lens.x, lens.y);
                particle.draw();
            });
            
            // Draw transformation lens
            lens.draw();
            
            // Draw clear shapes
            shapes.forEach(shape => {
                shape.update();
                shape.draw();
            });
            
            requestAnimationFrame(animate);
        }
        
        // Handle resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Update lens position
            lens.x = canvas.width / 2;
            lens.y = canvas.height / 2;
            pointer.x = canvas.width / 2;
            pointer.y = canvas.height / 2;
            pointer.active = false;
            
            // Update clear shapes positions
            positionShapes(shapes);
            
            // Update particle targets
            particles.forEach(particle => {
                particle.targetX = canvas.width * 0.5;
                particle.targetY = canvas.height * 0.5;
            });
        });
        
        // Start animation
        animate();
    </script>
</body>
</html>
